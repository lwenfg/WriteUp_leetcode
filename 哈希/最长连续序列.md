# Problem: [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/)
> 给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题


## 思路
要找出未排序整数数组中数字连续的最长序列长度，核心思路是使用哈希集合优化查找效率。算法步骤如下：

1. 使用集合存储，将数组元素放入集合之中，因为在集合中查找元素的时间复杂度为O(1)，而使用数组查找元素的时间复杂度为O(n).

2. 遍历集合每一个元素，若该元素的前一个数字不在集合里，则将其作为序列的第一个元素，然后使用while循环向后查找连续的数字并计算长度。

3. 比较并更新最长序列长度


## 复杂度
创建集合需要空间复杂度$O(n)$，遍历集合需要时间复杂度$O(n)$。
- 时间复杂度: $O(n)$
- 空间复杂度: $O(n)$



## Code
```Python3 []
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        max_lenth = 0
        num_set = set(nums)

        for num in num_set:
            if num-1 not in num_set:
                current_num = num
                current_lenth = 1

                while current_num + 1 in num_set:
                    current_num += 1
                    current_lenth += 1
                
                max_lenth = max(max_lenth,current_lenth)

        return max_lenth
```

## 题后思考

这道题要求时间复杂度为O(n)，所以不能使用排序算法，因为排序算法最快的时间复杂度为O(nlogn).

在Python中，集合是基于哈希表实现的。哈希表是一种数据结构，它通过计算元素的哈希值来快速定位存储位置，查找操作只需要常数时间（即O(1)），从而实现高效查找。

而列表的in操作需要从头到尾遍历元素，直到找到匹配项，因此时间复杂度总是O(n).

集合（set）是一种无序且不重复的数据结构。当我们使用`set(nums)`将列表`nums`转换为集合时，集合会自动去除列表中的重复元素。这是因为集合的数学定义要求其元素必须是唯一的。